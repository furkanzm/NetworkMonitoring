// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: monitoring.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_monitoring_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_monitoring_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_monitoring_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_monitoring_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_monitoring_2eproto;
namespace mon {
class AllDiskResponse;
struct AllDiskResponseDefaultTypeInternal;
extern AllDiskResponseDefaultTypeInternal _AllDiskResponse_default_instance_;
class AllIfaceResponses;
struct AllIfaceResponsesDefaultTypeInternal;
extern AllIfaceResponsesDefaultTypeInternal _AllIfaceResponses_default_instance_;
class CachedMemory;
struct CachedMemoryDefaultTypeInternal;
extern CachedMemoryDefaultTypeInternal _CachedMemory_default_instance_;
class CpuResponse;
struct CpuResponseDefaultTypeInternal;
extern CpuResponseDefaultTypeInternal _CpuResponse_default_instance_;
class DiskQ;
struct DiskQDefaultTypeInternal;
extern DiskQDefaultTypeInternal _DiskQ_default_instance_;
class DiskResponse;
struct DiskResponseDefaultTypeInternal;
extern DiskResponseDefaultTypeInternal _DiskResponse_default_instance_;
class DiskValue;
struct DiskValueDefaultTypeInternal;
extern DiskValueDefaultTypeInternal _DiskValue_default_instance_;
class FreeMemory;
struct FreeMemoryDefaultTypeInternal;
extern FreeMemoryDefaultTypeInternal _FreeMemory_default_instance_;
class IfaceQ;
struct IfaceQDefaultTypeInternal;
extern IfaceQDefaultTypeInternal _IfaceQ_default_instance_;
class IfaceResponse;
struct IfaceResponseDefaultTypeInternal;
extern IfaceResponseDefaultTypeInternal _IfaceResponse_default_instance_;
class IfaceValue;
struct IfaceValueDefaultTypeInternal;
extern IfaceValueDefaultTypeInternal _IfaceValue_default_instance_;
class SwapMemory;
struct SwapMemoryDefaultTypeInternal;
extern SwapMemoryDefaultTypeInternal _SwapMemory_default_instance_;
class TotalMemory;
struct TotalMemoryDefaultTypeInternal;
extern TotalMemoryDefaultTypeInternal _TotalMemory_default_instance_;
class UsedMemory;
struct UsedMemoryDefaultTypeInternal;
extern UsedMemoryDefaultTypeInternal _UsedMemory_default_instance_;
}  // namespace mon
PROTOBUF_NAMESPACE_OPEN
template<> ::mon::AllDiskResponse* Arena::CreateMaybeMessage<::mon::AllDiskResponse>(Arena*);
template<> ::mon::AllIfaceResponses* Arena::CreateMaybeMessage<::mon::AllIfaceResponses>(Arena*);
template<> ::mon::CachedMemory* Arena::CreateMaybeMessage<::mon::CachedMemory>(Arena*);
template<> ::mon::CpuResponse* Arena::CreateMaybeMessage<::mon::CpuResponse>(Arena*);
template<> ::mon::DiskQ* Arena::CreateMaybeMessage<::mon::DiskQ>(Arena*);
template<> ::mon::DiskResponse* Arena::CreateMaybeMessage<::mon::DiskResponse>(Arena*);
template<> ::mon::DiskValue* Arena::CreateMaybeMessage<::mon::DiskValue>(Arena*);
template<> ::mon::FreeMemory* Arena::CreateMaybeMessage<::mon::FreeMemory>(Arena*);
template<> ::mon::IfaceQ* Arena::CreateMaybeMessage<::mon::IfaceQ>(Arena*);
template<> ::mon::IfaceResponse* Arena::CreateMaybeMessage<::mon::IfaceResponse>(Arena*);
template<> ::mon::IfaceValue* Arena::CreateMaybeMessage<::mon::IfaceValue>(Arena*);
template<> ::mon::SwapMemory* Arena::CreateMaybeMessage<::mon::SwapMemory>(Arena*);
template<> ::mon::TotalMemory* Arena::CreateMaybeMessage<::mon::TotalMemory>(Arena*);
template<> ::mon::UsedMemory* Arena::CreateMaybeMessage<::mon::UsedMemory>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mon {

// ===================================================================

class DiskValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.DiskValue) */ {
 public:
  inline DiskValue() : DiskValue(nullptr) {}
  ~DiskValue() override;
  explicit constexpr DiskValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskValue(const DiskValue& from);
  DiskValue(DiskValue&& from) noexcept
    : DiskValue() {
    *this = ::std::move(from);
  }

  inline DiskValue& operator=(const DiskValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskValue& operator=(DiskValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskValue* internal_default_instance() {
    return reinterpret_cast<const DiskValue*>(
               &_DiskValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DiskValue& a, DiskValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiskValue* New() const final {
    return new DiskValue();
  }

  DiskValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiskValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiskValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DiskValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.DiskValue";
  }
  protected:
  explicit DiskValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kWFieldNumber = 2,
    kRwFieldNumber = 3,
  };
  // int64 r = 1;
  void clear_r();
  ::PROTOBUF_NAMESPACE_ID::int64 r() const;
  void set_r(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_r() const;
  void _internal_set_r(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 w = 2;
  void clear_w();
  ::PROTOBUF_NAMESPACE_ID::int64 w() const;
  void set_w(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_w() const;
  void _internal_set_w(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 rw = 3;
  void clear_rw();
  ::PROTOBUF_NAMESPACE_ID::int64 rw() const;
  void set_rw(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_rw() const;
  void _internal_set_rw(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mon.DiskValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 r_;
  ::PROTOBUF_NAMESPACE_ID::int64 w_;
  ::PROTOBUF_NAMESPACE_ID::int64 rw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class DiskResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.DiskResponse) */ {
 public:
  inline DiskResponse() : DiskResponse(nullptr) {}
  ~DiskResponse() override;
  explicit constexpr DiskResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskResponse(const DiskResponse& from);
  DiskResponse(DiskResponse&& from) noexcept
    : DiskResponse() {
    *this = ::std::move(from);
  }

  inline DiskResponse& operator=(const DiskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskResponse& operator=(DiskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskResponse* internal_default_instance() {
    return reinterpret_cast<const DiskResponse*>(
               &_DiskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DiskResponse& a, DiskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiskResponse* New() const final {
    return new DiskResponse();
  }

  DiskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiskResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiskResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DiskResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.DiskResponse";
  }
  protected:
  explicit DiskResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mon.DiskValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::mon::DiskValue& value() const;
  PROTOBUF_MUST_USE_RESULT ::mon::DiskValue* release_value();
  ::mon::DiskValue* mutable_value();
  void set_allocated_value(::mon::DiskValue* value);
  private:
  const ::mon::DiskValue& _internal_value() const;
  ::mon::DiskValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::mon::DiskValue* value);
  ::mon::DiskValue* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:mon.DiskResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mon::DiskValue* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class AllDiskResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.AllDiskResponse) */ {
 public:
  inline AllDiskResponse() : AllDiskResponse(nullptr) {}
  ~AllDiskResponse() override;
  explicit constexpr AllDiskResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllDiskResponse(const AllDiskResponse& from);
  AllDiskResponse(AllDiskResponse&& from) noexcept
    : AllDiskResponse() {
    *this = ::std::move(from);
  }

  inline AllDiskResponse& operator=(const AllDiskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllDiskResponse& operator=(AllDiskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllDiskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllDiskResponse* internal_default_instance() {
    return reinterpret_cast<const AllDiskResponse*>(
               &_AllDiskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AllDiskResponse& a, AllDiskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AllDiskResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllDiskResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllDiskResponse* New() const final {
    return new AllDiskResponse();
  }

  AllDiskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllDiskResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllDiskResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AllDiskResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllDiskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.AllDiskResponse";
  }
  protected:
  explicit AllDiskResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRespFieldNumber = 1,
  };
  // repeated .mon.DiskResponse resp = 1;
  int resp_size() const;
  private:
  int _internal_resp_size() const;
  public:
  void clear_resp();
  ::mon::DiskResponse* mutable_resp(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::DiskResponse >*
      mutable_resp();
  private:
  const ::mon::DiskResponse& _internal_resp(int index) const;
  ::mon::DiskResponse* _internal_add_resp();
  public:
  const ::mon::DiskResponse& resp(int index) const;
  ::mon::DiskResponse* add_resp();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::DiskResponse >&
      resp() const;

  // @@protoc_insertion_point(class_scope:mon.AllDiskResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::DiskResponse > resp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class DiskQ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.DiskQ) */ {
 public:
  inline DiskQ() : DiskQ(nullptr) {}
  ~DiskQ() override;
  explicit constexpr DiskQ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskQ(const DiskQ& from);
  DiskQ(DiskQ&& from) noexcept
    : DiskQ() {
    *this = ::std::move(from);
  }

  inline DiskQ& operator=(const DiskQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskQ& operator=(DiskQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskQ* internal_default_instance() {
    return reinterpret_cast<const DiskQ*>(
               &_DiskQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DiskQ& a, DiskQ& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskQ* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskQ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiskQ* New() const final {
    return new DiskQ();
  }

  DiskQ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiskQ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiskQ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DiskQ& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskQ* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.DiskQ";
  }
  protected:
  explicit DiskQ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mon.DiskQ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class IfaceQ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.IfaceQ) */ {
 public:
  inline IfaceQ() : IfaceQ(nullptr) {}
  ~IfaceQ() override;
  explicit constexpr IfaceQ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IfaceQ(const IfaceQ& from);
  IfaceQ(IfaceQ&& from) noexcept
    : IfaceQ() {
    *this = ::std::move(from);
  }

  inline IfaceQ& operator=(const IfaceQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline IfaceQ& operator=(IfaceQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IfaceQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const IfaceQ* internal_default_instance() {
    return reinterpret_cast<const IfaceQ*>(
               &_IfaceQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IfaceQ& a, IfaceQ& b) {
    a.Swap(&b);
  }
  inline void Swap(IfaceQ* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IfaceQ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IfaceQ* New() const final {
    return new IfaceQ();
  }

  IfaceQ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IfaceQ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IfaceQ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IfaceQ& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfaceQ* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.IfaceQ";
  }
  protected:
  explicit IfaceQ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mon.IfaceQ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class IfaceValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.IfaceValue) */ {
 public:
  inline IfaceValue() : IfaceValue(nullptr) {}
  ~IfaceValue() override;
  explicit constexpr IfaceValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IfaceValue(const IfaceValue& from);
  IfaceValue(IfaceValue&& from) noexcept
    : IfaceValue() {
    *this = ::std::move(from);
  }

  inline IfaceValue& operator=(const IfaceValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline IfaceValue& operator=(IfaceValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IfaceValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const IfaceValue* internal_default_instance() {
    return reinterpret_cast<const IfaceValue*>(
               &_IfaceValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(IfaceValue& a, IfaceValue& b) {
    a.Swap(&b);
  }
  inline void Swap(IfaceValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IfaceValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IfaceValue* New() const final {
    return new IfaceValue();
  }

  IfaceValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IfaceValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IfaceValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IfaceValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfaceValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.IfaceValue";
  }
  protected:
  explicit IfaceValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kWFieldNumber = 2,
    kRwFieldNumber = 3,
  };
  // int64 r = 1;
  void clear_r();
  ::PROTOBUF_NAMESPACE_ID::int64 r() const;
  void set_r(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_r() const;
  void _internal_set_r(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 w = 2;
  void clear_w();
  ::PROTOBUF_NAMESPACE_ID::int64 w() const;
  void set_w(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_w() const;
  void _internal_set_w(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 rw = 3;
  void clear_rw();
  ::PROTOBUF_NAMESPACE_ID::int64 rw() const;
  void set_rw(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_rw() const;
  void _internal_set_rw(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mon.IfaceValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 r_;
  ::PROTOBUF_NAMESPACE_ID::int64 w_;
  ::PROTOBUF_NAMESPACE_ID::int64 rw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class IfaceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.IfaceResponse) */ {
 public:
  inline IfaceResponse() : IfaceResponse(nullptr) {}
  ~IfaceResponse() override;
  explicit constexpr IfaceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IfaceResponse(const IfaceResponse& from);
  IfaceResponse(IfaceResponse&& from) noexcept
    : IfaceResponse() {
    *this = ::std::move(from);
  }

  inline IfaceResponse& operator=(const IfaceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IfaceResponse& operator=(IfaceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IfaceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IfaceResponse* internal_default_instance() {
    return reinterpret_cast<const IfaceResponse*>(
               &_IfaceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IfaceResponse& a, IfaceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IfaceResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IfaceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IfaceResponse* New() const final {
    return new IfaceResponse();
  }

  IfaceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IfaceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IfaceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IfaceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfaceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.IfaceResponse";
  }
  protected:
  explicit IfaceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mon.IfaceValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::mon::IfaceValue& value() const;
  PROTOBUF_MUST_USE_RESULT ::mon::IfaceValue* release_value();
  ::mon::IfaceValue* mutable_value();
  void set_allocated_value(::mon::IfaceValue* value);
  private:
  const ::mon::IfaceValue& _internal_value() const;
  ::mon::IfaceValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::mon::IfaceValue* value);
  ::mon::IfaceValue* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:mon.IfaceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mon::IfaceValue* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class AllIfaceResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.AllIfaceResponses) */ {
 public:
  inline AllIfaceResponses() : AllIfaceResponses(nullptr) {}
  ~AllIfaceResponses() override;
  explicit constexpr AllIfaceResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllIfaceResponses(const AllIfaceResponses& from);
  AllIfaceResponses(AllIfaceResponses&& from) noexcept
    : AllIfaceResponses() {
    *this = ::std::move(from);
  }

  inline AllIfaceResponses& operator=(const AllIfaceResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllIfaceResponses& operator=(AllIfaceResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllIfaceResponses& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllIfaceResponses* internal_default_instance() {
    return reinterpret_cast<const AllIfaceResponses*>(
               &_AllIfaceResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AllIfaceResponses& a, AllIfaceResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(AllIfaceResponses* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllIfaceResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllIfaceResponses* New() const final {
    return new AllIfaceResponses();
  }

  AllIfaceResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllIfaceResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllIfaceResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AllIfaceResponses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllIfaceResponses* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.AllIfaceResponses";
  }
  protected:
  explicit AllIfaceResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfaceFieldNumber = 1,
  };
  // repeated .mon.IfaceResponse iface = 1;
  int iface_size() const;
  private:
  int _internal_iface_size() const;
  public:
  void clear_iface();
  ::mon::IfaceResponse* mutable_iface(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::IfaceResponse >*
      mutable_iface();
  private:
  const ::mon::IfaceResponse& _internal_iface(int index) const;
  ::mon::IfaceResponse* _internal_add_iface();
  public:
  const ::mon::IfaceResponse& iface(int index) const;
  ::mon::IfaceResponse* add_iface();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::IfaceResponse >&
      iface() const;

  // @@protoc_insertion_point(class_scope:mon.AllIfaceResponses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::IfaceResponse > iface_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class FreeMemory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.FreeMemory) */ {
 public:
  inline FreeMemory() : FreeMemory(nullptr) {}
  ~FreeMemory() override;
  explicit constexpr FreeMemory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreeMemory(const FreeMemory& from);
  FreeMemory(FreeMemory&& from) noexcept
    : FreeMemory() {
    *this = ::std::move(from);
  }

  inline FreeMemory& operator=(const FreeMemory& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreeMemory& operator=(FreeMemory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreeMemory& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreeMemory* internal_default_instance() {
    return reinterpret_cast<const FreeMemory*>(
               &_FreeMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FreeMemory& a, FreeMemory& b) {
    a.Swap(&b);
  }
  inline void Swap(FreeMemory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreeMemory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FreeMemory* New() const final {
    return new FreeMemory();
  }

  FreeMemory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FreeMemory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FreeMemory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FreeMemory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreeMemory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.FreeMemory";
  }
  protected:
  explicit FreeMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int64 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mon.FreeMemory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class UsedMemory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.UsedMemory) */ {
 public:
  inline UsedMemory() : UsedMemory(nullptr) {}
  ~UsedMemory() override;
  explicit constexpr UsedMemory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsedMemory(const UsedMemory& from);
  UsedMemory(UsedMemory&& from) noexcept
    : UsedMemory() {
    *this = ::std::move(from);
  }

  inline UsedMemory& operator=(const UsedMemory& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsedMemory& operator=(UsedMemory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsedMemory& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsedMemory* internal_default_instance() {
    return reinterpret_cast<const UsedMemory*>(
               &_UsedMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UsedMemory& a, UsedMemory& b) {
    a.Swap(&b);
  }
  inline void Swap(UsedMemory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsedMemory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsedMemory* New() const final {
    return new UsedMemory();
  }

  UsedMemory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsedMemory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsedMemory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UsedMemory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsedMemory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.UsedMemory";
  }
  protected:
  explicit UsedMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int64 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mon.UsedMemory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class CachedMemory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.CachedMemory) */ {
 public:
  inline CachedMemory() : CachedMemory(nullptr) {}
  ~CachedMemory() override;
  explicit constexpr CachedMemory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CachedMemory(const CachedMemory& from);
  CachedMemory(CachedMemory&& from) noexcept
    : CachedMemory() {
    *this = ::std::move(from);
  }

  inline CachedMemory& operator=(const CachedMemory& from) {
    CopyFrom(from);
    return *this;
  }
  inline CachedMemory& operator=(CachedMemory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CachedMemory& default_instance() {
    return *internal_default_instance();
  }
  static inline const CachedMemory* internal_default_instance() {
    return reinterpret_cast<const CachedMemory*>(
               &_CachedMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CachedMemory& a, CachedMemory& b) {
    a.Swap(&b);
  }
  inline void Swap(CachedMemory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CachedMemory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CachedMemory* New() const final {
    return new CachedMemory();
  }

  CachedMemory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CachedMemory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CachedMemory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CachedMemory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CachedMemory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.CachedMemory";
  }
  protected:
  explicit CachedMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int64 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mon.CachedMemory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class SwapMemory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.SwapMemory) */ {
 public:
  inline SwapMemory() : SwapMemory(nullptr) {}
  ~SwapMemory() override;
  explicit constexpr SwapMemory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwapMemory(const SwapMemory& from);
  SwapMemory(SwapMemory&& from) noexcept
    : SwapMemory() {
    *this = ::std::move(from);
  }

  inline SwapMemory& operator=(const SwapMemory& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapMemory& operator=(SwapMemory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwapMemory& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwapMemory* internal_default_instance() {
    return reinterpret_cast<const SwapMemory*>(
               &_SwapMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SwapMemory& a, SwapMemory& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapMemory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwapMemory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SwapMemory* New() const final {
    return new SwapMemory();
  }

  SwapMemory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwapMemory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwapMemory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SwapMemory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapMemory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.SwapMemory";
  }
  protected:
  explicit SwapMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int64 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mon.SwapMemory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class TotalMemory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.TotalMemory) */ {
 public:
  inline TotalMemory() : TotalMemory(nullptr) {}
  ~TotalMemory() override;
  explicit constexpr TotalMemory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TotalMemory(const TotalMemory& from);
  TotalMemory(TotalMemory&& from) noexcept
    : TotalMemory() {
    *this = ::std::move(from);
  }

  inline TotalMemory& operator=(const TotalMemory& from) {
    CopyFrom(from);
    return *this;
  }
  inline TotalMemory& operator=(TotalMemory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TotalMemory& default_instance() {
    return *internal_default_instance();
  }
  static inline const TotalMemory* internal_default_instance() {
    return reinterpret_cast<const TotalMemory*>(
               &_TotalMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TotalMemory& a, TotalMemory& b) {
    a.Swap(&b);
  }
  inline void Swap(TotalMemory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TotalMemory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TotalMemory* New() const final {
    return new TotalMemory();
  }

  TotalMemory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TotalMemory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TotalMemory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TotalMemory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TotalMemory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.TotalMemory";
  }
  protected:
  explicit TotalMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int64 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mon.TotalMemory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class CpuResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mon.CpuResponse) */ {
 public:
  inline CpuResponse() : CpuResponse(nullptr) {}
  ~CpuResponse() override;
  explicit constexpr CpuResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CpuResponse(const CpuResponse& from);
  CpuResponse(CpuResponse&& from) noexcept
    : CpuResponse() {
    *this = ::std::move(from);
  }

  inline CpuResponse& operator=(const CpuResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpuResponse& operator=(CpuResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CpuResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CpuResponse* internal_default_instance() {
    return reinterpret_cast<const CpuResponse*>(
               &_CpuResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CpuResponse& a, CpuResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CpuResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpuResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CpuResponse* New() const final {
    return new CpuResponse();
  }

  CpuResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CpuResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CpuResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CpuResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CpuResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mon.CpuResponse";
  }
  protected:
  explicit CpuResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated float value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  float _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_value() const;
  void _internal_add_value(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_value();
  public:
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:mon.CpuResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_monitoring_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DiskValue

// int64 r = 1;
inline void DiskValue::clear_r() {
  r_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskValue::_internal_r() const {
  return r_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskValue::r() const {
  // @@protoc_insertion_point(field_get:mon.DiskValue.r)
  return _internal_r();
}
inline void DiskValue::_internal_set_r(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  r_ = value;
}
inline void DiskValue::set_r(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:mon.DiskValue.r)
}

// int64 w = 2;
inline void DiskValue::clear_w() {
  w_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskValue::_internal_w() const {
  return w_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskValue::w() const {
  // @@protoc_insertion_point(field_get:mon.DiskValue.w)
  return _internal_w();
}
inline void DiskValue::_internal_set_w(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  w_ = value;
}
inline void DiskValue::set_w(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:mon.DiskValue.w)
}

// int64 rw = 3;
inline void DiskValue::clear_rw() {
  rw_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskValue::_internal_rw() const {
  return rw_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskValue::rw() const {
  // @@protoc_insertion_point(field_get:mon.DiskValue.rw)
  return _internal_rw();
}
inline void DiskValue::_internal_set_rw(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  rw_ = value;
}
inline void DiskValue::set_rw(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_rw(value);
  // @@protoc_insertion_point(field_set:mon.DiskValue.rw)
}

// -------------------------------------------------------------------

// DiskResponse

// string name = 1;
inline void DiskResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DiskResponse::name() const {
  // @@protoc_insertion_point(field_get:mon.DiskResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mon.DiskResponse.name)
}
inline std::string* DiskResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mon.DiskResponse.name)
  return _s;
}
inline const std::string& DiskResponse::_internal_name() const {
  return name_.Get();
}
inline void DiskResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DiskResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DiskResponse::release_name() {
  // @@protoc_insertion_point(field_release:mon.DiskResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DiskResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mon.DiskResponse.name)
}

// .mon.DiskValue value = 2;
inline bool DiskResponse::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool DiskResponse::has_value() const {
  return _internal_has_value();
}
inline void DiskResponse::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::mon::DiskValue& DiskResponse::_internal_value() const {
  const ::mon::DiskValue* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::mon::DiskValue&>(
      ::mon::_DiskValue_default_instance_);
}
inline const ::mon::DiskValue& DiskResponse::value() const {
  // @@protoc_insertion_point(field_get:mon.DiskResponse.value)
  return _internal_value();
}
inline void DiskResponse::unsafe_arena_set_allocated_value(
    ::mon::DiskValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mon.DiskResponse.value)
}
inline ::mon::DiskValue* DiskResponse::release_value() {
  
  ::mon::DiskValue* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mon::DiskValue* DiskResponse::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:mon.DiskResponse.value)
  
  ::mon::DiskValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::mon::DiskValue* DiskResponse::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::mon::DiskValue>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::mon::DiskValue* DiskResponse::mutable_value() {
  ::mon::DiskValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:mon.DiskResponse.value)
  return _msg;
}
inline void DiskResponse::set_allocated_value(::mon::DiskValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mon::DiskValue>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:mon.DiskResponse.value)
}

// -------------------------------------------------------------------

// AllDiskResponse

// repeated .mon.DiskResponse resp = 1;
inline int AllDiskResponse::_internal_resp_size() const {
  return resp_.size();
}
inline int AllDiskResponse::resp_size() const {
  return _internal_resp_size();
}
inline void AllDiskResponse::clear_resp() {
  resp_.Clear();
}
inline ::mon::DiskResponse* AllDiskResponse::mutable_resp(int index) {
  // @@protoc_insertion_point(field_mutable:mon.AllDiskResponse.resp)
  return resp_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::DiskResponse >*
AllDiskResponse::mutable_resp() {
  // @@protoc_insertion_point(field_mutable_list:mon.AllDiskResponse.resp)
  return &resp_;
}
inline const ::mon::DiskResponse& AllDiskResponse::_internal_resp(int index) const {
  return resp_.Get(index);
}
inline const ::mon::DiskResponse& AllDiskResponse::resp(int index) const {
  // @@protoc_insertion_point(field_get:mon.AllDiskResponse.resp)
  return _internal_resp(index);
}
inline ::mon::DiskResponse* AllDiskResponse::_internal_add_resp() {
  return resp_.Add();
}
inline ::mon::DiskResponse* AllDiskResponse::add_resp() {
  ::mon::DiskResponse* _add = _internal_add_resp();
  // @@protoc_insertion_point(field_add:mon.AllDiskResponse.resp)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::DiskResponse >&
AllDiskResponse::resp() const {
  // @@protoc_insertion_point(field_list:mon.AllDiskResponse.resp)
  return resp_;
}

// -------------------------------------------------------------------

// DiskQ

// string name = 1;
inline void DiskQ::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DiskQ::name() const {
  // @@protoc_insertion_point(field_get:mon.DiskQ.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskQ::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mon.DiskQ.name)
}
inline std::string* DiskQ::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mon.DiskQ.name)
  return _s;
}
inline const std::string& DiskQ::_internal_name() const {
  return name_.Get();
}
inline void DiskQ::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DiskQ::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DiskQ::release_name() {
  // @@protoc_insertion_point(field_release:mon.DiskQ.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DiskQ::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mon.DiskQ.name)
}

// -------------------------------------------------------------------

// IfaceQ

// string name = 1;
inline void IfaceQ::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& IfaceQ::name() const {
  // @@protoc_insertion_point(field_get:mon.IfaceQ.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IfaceQ::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mon.IfaceQ.name)
}
inline std::string* IfaceQ::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mon.IfaceQ.name)
  return _s;
}
inline const std::string& IfaceQ::_internal_name() const {
  return name_.Get();
}
inline void IfaceQ::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IfaceQ::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IfaceQ::release_name() {
  // @@protoc_insertion_point(field_release:mon.IfaceQ.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IfaceQ::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mon.IfaceQ.name)
}

// -------------------------------------------------------------------

// IfaceValue

// int64 r = 1;
inline void IfaceValue::clear_r() {
  r_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IfaceValue::_internal_r() const {
  return r_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IfaceValue::r() const {
  // @@protoc_insertion_point(field_get:mon.IfaceValue.r)
  return _internal_r();
}
inline void IfaceValue::_internal_set_r(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  r_ = value;
}
inline void IfaceValue::set_r(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:mon.IfaceValue.r)
}

// int64 w = 2;
inline void IfaceValue::clear_w() {
  w_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IfaceValue::_internal_w() const {
  return w_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IfaceValue::w() const {
  // @@protoc_insertion_point(field_get:mon.IfaceValue.w)
  return _internal_w();
}
inline void IfaceValue::_internal_set_w(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  w_ = value;
}
inline void IfaceValue::set_w(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:mon.IfaceValue.w)
}

// int64 rw = 3;
inline void IfaceValue::clear_rw() {
  rw_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IfaceValue::_internal_rw() const {
  return rw_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IfaceValue::rw() const {
  // @@protoc_insertion_point(field_get:mon.IfaceValue.rw)
  return _internal_rw();
}
inline void IfaceValue::_internal_set_rw(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  rw_ = value;
}
inline void IfaceValue::set_rw(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_rw(value);
  // @@protoc_insertion_point(field_set:mon.IfaceValue.rw)
}

// -------------------------------------------------------------------

// IfaceResponse

// string name = 1;
inline void IfaceResponse::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& IfaceResponse::name() const {
  // @@protoc_insertion_point(field_get:mon.IfaceResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IfaceResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mon.IfaceResponse.name)
}
inline std::string* IfaceResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mon.IfaceResponse.name)
  return _s;
}
inline const std::string& IfaceResponse::_internal_name() const {
  return name_.Get();
}
inline void IfaceResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IfaceResponse::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IfaceResponse::release_name() {
  // @@protoc_insertion_point(field_release:mon.IfaceResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IfaceResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mon.IfaceResponse.name)
}

// .mon.IfaceValue value = 2;
inline bool IfaceResponse::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool IfaceResponse::has_value() const {
  return _internal_has_value();
}
inline void IfaceResponse::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::mon::IfaceValue& IfaceResponse::_internal_value() const {
  const ::mon::IfaceValue* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::mon::IfaceValue&>(
      ::mon::_IfaceValue_default_instance_);
}
inline const ::mon::IfaceValue& IfaceResponse::value() const {
  // @@protoc_insertion_point(field_get:mon.IfaceResponse.value)
  return _internal_value();
}
inline void IfaceResponse::unsafe_arena_set_allocated_value(
    ::mon::IfaceValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mon.IfaceResponse.value)
}
inline ::mon::IfaceValue* IfaceResponse::release_value() {
  
  ::mon::IfaceValue* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mon::IfaceValue* IfaceResponse::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:mon.IfaceResponse.value)
  
  ::mon::IfaceValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::mon::IfaceValue* IfaceResponse::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::mon::IfaceValue>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::mon::IfaceValue* IfaceResponse::mutable_value() {
  ::mon::IfaceValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:mon.IfaceResponse.value)
  return _msg;
}
inline void IfaceResponse::set_allocated_value(::mon::IfaceValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mon::IfaceValue>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:mon.IfaceResponse.value)
}

// -------------------------------------------------------------------

// AllIfaceResponses

// repeated .mon.IfaceResponse iface = 1;
inline int AllIfaceResponses::_internal_iface_size() const {
  return iface_.size();
}
inline int AllIfaceResponses::iface_size() const {
  return _internal_iface_size();
}
inline void AllIfaceResponses::clear_iface() {
  iface_.Clear();
}
inline ::mon::IfaceResponse* AllIfaceResponses::mutable_iface(int index) {
  // @@protoc_insertion_point(field_mutable:mon.AllIfaceResponses.iface)
  return iface_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::IfaceResponse >*
AllIfaceResponses::mutable_iface() {
  // @@protoc_insertion_point(field_mutable_list:mon.AllIfaceResponses.iface)
  return &iface_;
}
inline const ::mon::IfaceResponse& AllIfaceResponses::_internal_iface(int index) const {
  return iface_.Get(index);
}
inline const ::mon::IfaceResponse& AllIfaceResponses::iface(int index) const {
  // @@protoc_insertion_point(field_get:mon.AllIfaceResponses.iface)
  return _internal_iface(index);
}
inline ::mon::IfaceResponse* AllIfaceResponses::_internal_add_iface() {
  return iface_.Add();
}
inline ::mon::IfaceResponse* AllIfaceResponses::add_iface() {
  ::mon::IfaceResponse* _add = _internal_add_iface();
  // @@protoc_insertion_point(field_add:mon.AllIfaceResponses.iface)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mon::IfaceResponse >&
AllIfaceResponses::iface() const {
  // @@protoc_insertion_point(field_list:mon.AllIfaceResponses.iface)
  return iface_;
}

// -------------------------------------------------------------------

// FreeMemory

// int64 value = 1;
inline void FreeMemory::clear_value() {
  value_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FreeMemory::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FreeMemory::value() const {
  // @@protoc_insertion_point(field_get:mon.FreeMemory.value)
  return _internal_value();
}
inline void FreeMemory::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  value_ = value;
}
inline void FreeMemory::set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mon.FreeMemory.value)
}

// -------------------------------------------------------------------

// UsedMemory

// int64 value = 1;
inline void UsedMemory::clear_value() {
  value_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UsedMemory::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UsedMemory::value() const {
  // @@protoc_insertion_point(field_get:mon.UsedMemory.value)
  return _internal_value();
}
inline void UsedMemory::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  value_ = value;
}
inline void UsedMemory::set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mon.UsedMemory.value)
}

// -------------------------------------------------------------------

// CachedMemory

// int64 value = 1;
inline void CachedMemory::clear_value() {
  value_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CachedMemory::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CachedMemory::value() const {
  // @@protoc_insertion_point(field_get:mon.CachedMemory.value)
  return _internal_value();
}
inline void CachedMemory::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  value_ = value;
}
inline void CachedMemory::set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mon.CachedMemory.value)
}

// -------------------------------------------------------------------

// SwapMemory

// int64 value = 1;
inline void SwapMemory::clear_value() {
  value_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SwapMemory::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SwapMemory::value() const {
  // @@protoc_insertion_point(field_get:mon.SwapMemory.value)
  return _internal_value();
}
inline void SwapMemory::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  value_ = value;
}
inline void SwapMemory::set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mon.SwapMemory.value)
}

// -------------------------------------------------------------------

// TotalMemory

// int64 value = 1;
inline void TotalMemory::clear_value() {
  value_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TotalMemory::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TotalMemory::value() const {
  // @@protoc_insertion_point(field_get:mon.TotalMemory.value)
  return _internal_value();
}
inline void TotalMemory::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  value_ = value;
}
inline void TotalMemory::set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mon.TotalMemory.value)
}

// -------------------------------------------------------------------

// CpuResponse

// repeated float value = 1;
inline int CpuResponse::_internal_value_size() const {
  return value_.size();
}
inline int CpuResponse::value_size() const {
  return _internal_value_size();
}
inline void CpuResponse::clear_value() {
  value_.Clear();
}
inline float CpuResponse::_internal_value(int index) const {
  return value_.Get(index);
}
inline float CpuResponse::value(int index) const {
  // @@protoc_insertion_point(field_get:mon.CpuResponse.value)
  return _internal_value(index);
}
inline void CpuResponse::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:mon.CpuResponse.value)
}
inline void CpuResponse::_internal_add_value(float value) {
  value_.Add(value);
}
inline void CpuResponse::add_value(float value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:mon.CpuResponse.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CpuResponse::_internal_value() const {
  return value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CpuResponse::value() const {
  // @@protoc_insertion_point(field_list:mon.CpuResponse.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CpuResponse::_internal_mutable_value() {
  return &value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CpuResponse::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:mon.CpuResponse.value)
  return _internal_mutable_value();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mon

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_monitoring_2eproto
