// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: monitoring.proto
#ifndef GRPC_monitoring_2eproto__INCLUDED
#define GRPC_monitoring_2eproto__INCLUDED

#include "monitoring.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace mon {

// Disk
class DiskMonitoring final {
 public:
  static constexpr char const* service_full_name() {
    return "mon.DiskMonitoring";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllDiskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>> AsyncGetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>>(AsyncGetBPSRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>> PrepareAsyncGetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>>(PrepareAsyncGetBPSRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::mon::DiskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>> AsyncGetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>>(AsyncGetDiskBPSRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>> PrepareAsyncGetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>>(PrepareAsyncGetDiskBPSRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllDiskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>> AsyncGetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>>(AsyncGetIOPSRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>> PrepareAsyncGetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>>(PrepareAsyncGetIOPSRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::mon::DiskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>> AsyncGetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>>(AsyncGetDiskIOPSRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>> PrepareAsyncGetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>>(PrepareAsyncGetDiskIOPSRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllDiskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>> AsyncGetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>>(AsyncGetRequestSizeInBytesPerReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>> PrepareAsyncGetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>>(PrepareAsyncGetRequestSizeInBytesPerReadRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::mon::DiskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>> AsyncGetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>>(AsyncGetDiskRequestSizeInBytesPerReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>> PrepareAsyncGetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>>(PrepareAsyncGetDiskRequestSizeInBytesPerReadRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>* AsyncGetBPSRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>* PrepareAsyncGetBPSRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>* AsyncGetDiskBPSRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>* PrepareAsyncGetDiskBPSRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>* AsyncGetIOPSRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>* PrepareAsyncGetIOPSRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>* AsyncGetDiskIOPSRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>* PrepareAsyncGetDiskIOPSRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>* AsyncGetRequestSizeInBytesPerReadRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllDiskResponse>* PrepareAsyncGetRequestSizeInBytesPerReadRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>* AsyncGetDiskRequestSizeInBytesPerReadRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::DiskResponse>* PrepareAsyncGetDiskRequestSizeInBytesPerReadRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllDiskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>> AsyncGetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>>(AsyncGetBPSRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>> PrepareAsyncGetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>>(PrepareAsyncGetBPSRaw(context, request, cq));
    }
    ::grpc::Status GetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::mon::DiskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>> AsyncGetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>>(AsyncGetDiskBPSRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>> PrepareAsyncGetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>>(PrepareAsyncGetDiskBPSRaw(context, request, cq));
    }
    ::grpc::Status GetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllDiskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>> AsyncGetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>>(AsyncGetIOPSRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>> PrepareAsyncGetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>>(PrepareAsyncGetIOPSRaw(context, request, cq));
    }
    ::grpc::Status GetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::mon::DiskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>> AsyncGetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>>(AsyncGetDiskIOPSRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>> PrepareAsyncGetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>>(PrepareAsyncGetDiskIOPSRaw(context, request, cq));
    }
    ::grpc::Status GetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllDiskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>> AsyncGetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>>(AsyncGetRequestSizeInBytesPerReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>> PrepareAsyncGetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>>(PrepareAsyncGetRequestSizeInBytesPerReadRaw(context, request, cq));
    }
    ::grpc::Status GetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::mon::DiskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>> AsyncGetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>>(AsyncGetDiskRequestSizeInBytesPerReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>> PrepareAsyncGetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>>(PrepareAsyncGetDiskRequestSizeInBytesPerReadRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBPS(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDiskBPS(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, std::function<void(::grpc::Status)>) override;
      void GetIOPS(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDiskIOPS(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDiskRequestSizeInBytesPerRead(::grpc::ClientContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>* AsyncGetBPSRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>* PrepareAsyncGetBPSRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>* AsyncGetDiskBPSRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>* PrepareAsyncGetDiskBPSRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>* AsyncGetIOPSRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>* PrepareAsyncGetIOPSRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>* AsyncGetDiskIOPSRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>* PrepareAsyncGetDiskIOPSRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>* AsyncGetRequestSizeInBytesPerReadRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::AllDiskResponse>* PrepareAsyncGetRequestSizeInBytesPerReadRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>* AsyncGetDiskRequestSizeInBytesPerReadRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::DiskResponse>* PrepareAsyncGetDiskRequestSizeInBytesPerReadRaw(::grpc::ClientContext* context, const ::mon::DiskQ& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetBPS_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDiskBPS_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIOPS_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDiskIOPS_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRequestSizeInBytesPerRead_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDiskRequestSizeInBytesPerRead_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetBPS(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response);
    virtual ::grpc::Status GetDiskBPS(::grpc::ServerContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response);
    virtual ::grpc::Status GetIOPS(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response);
    virtual ::grpc::Status GetDiskIOPS(::grpc::ServerContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response);
    virtual ::grpc::Status GetRequestSizeInBytesPerRead(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response);
    virtual ::grpc::Status GetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBPS() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBPS(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::AllDiskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDiskBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDiskBPS() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetDiskBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskBPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDiskBPS(::grpc::ServerContext* context, ::mon::DiskQ* request, ::grpc::ServerAsyncResponseWriter< ::mon::DiskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetIOPS() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIOPS(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::AllDiskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDiskIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDiskIOPS() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetDiskIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskIOPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDiskIOPS(::grpc::ServerContext* context, ::mon::DiskQ* request, ::grpc::ServerAsyncResponseWriter< ::mon::DiskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRequestSizeInBytesPerRead(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::AllDiskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDiskRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDiskRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetDiskRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* context, ::mon::DiskQ* request, ::grpc::ServerAsyncResponseWriter< ::mon::DiskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetBPS<WithAsyncMethod_GetDiskBPS<WithAsyncMethod_GetIOPS<WithAsyncMethod_GetDiskIOPS<WithAsyncMethod_GetRequestSizeInBytesPerRead<WithAsyncMethod_GetDiskRequestSizeInBytesPerRead<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBPS() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllDiskResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response) { return this->GetBPS(context, request, response); }));}
    void SetMessageAllocatorFor_GetBPS(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::AllDiskResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllDiskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBPS(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDiskBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDiskBPS() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::mon::DiskQ, ::mon::DiskResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response) { return this->GetDiskBPS(context, request, response); }));}
    void SetMessageAllocatorFor_GetDiskBPS(
        ::grpc::MessageAllocator< ::mon::DiskQ, ::mon::DiskResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mon::DiskQ, ::mon::DiskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDiskBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskBPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDiskBPS(
      ::grpc::CallbackServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetIOPS() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllDiskResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response) { return this->GetIOPS(context, request, response); }));}
    void SetMessageAllocatorFor_GetIOPS(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::AllDiskResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllDiskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIOPS(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDiskIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDiskIOPS() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::mon::DiskQ, ::mon::DiskResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response) { return this->GetDiskIOPS(context, request, response); }));}
    void SetMessageAllocatorFor_GetDiskIOPS(
        ::grpc::MessageAllocator< ::mon::DiskQ, ::mon::DiskResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mon::DiskQ, ::mon::DiskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDiskIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskIOPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDiskIOPS(
      ::grpc::CallbackServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllDiskResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllDiskResponse* response) { return this->GetRequestSizeInBytesPerRead(context, request, response); }));}
    void SetMessageAllocatorFor_GetRequestSizeInBytesPerRead(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::AllDiskResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllDiskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRequestSizeInBytesPerRead(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDiskRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDiskRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::mon::DiskQ, ::mon::DiskResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mon::DiskQ* request, ::mon::DiskResponse* response) { return this->GetDiskRequestSizeInBytesPerRead(context, request, response); }));}
    void SetMessageAllocatorFor_GetDiskRequestSizeInBytesPerRead(
        ::grpc::MessageAllocator< ::mon::DiskQ, ::mon::DiskResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mon::DiskQ, ::mon::DiskResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDiskRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDiskRequestSizeInBytesPerRead(
      ::grpc::CallbackServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetBPS<WithCallbackMethod_GetDiskBPS<WithCallbackMethod_GetIOPS<WithCallbackMethod_GetDiskIOPS<WithCallbackMethod_GetRequestSizeInBytesPerRead<WithCallbackMethod_GetDiskRequestSizeInBytesPerRead<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBPS() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDiskBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDiskBPS() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetDiskBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskBPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetIOPS() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDiskIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDiskIOPS() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetDiskIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskIOPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDiskRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDiskRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetDiskRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBPS() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBPS(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDiskBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDiskBPS() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetDiskBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskBPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDiskBPS(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetIOPS() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIOPS(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDiskIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDiskIOPS() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetDiskIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskIOPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDiskIOPS(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRequestSizeInBytesPerRead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDiskRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDiskRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetDiskRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBPS() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBPS(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBPS(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDiskBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDiskBPS() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDiskBPS(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDiskBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskBPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDiskBPS(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetIOPS() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetIOPS(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIOPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIOPS(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDiskIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDiskIOPS() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDiskIOPS(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDiskIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskIOPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDiskIOPS(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRequestSizeInBytesPerRead(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRequestSizeInBytesPerRead(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDiskRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDiskRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDiskRequestSizeInBytesPerRead(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDiskRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDiskRequestSizeInBytesPerRead(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBPS() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::AllDiskResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::AllDiskResponse>* streamer) {
                       return this->StreamedGetBPS(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBPS(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::AllDiskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDiskBPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDiskBPS() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mon::DiskQ, ::mon::DiskResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mon::DiskQ, ::mon::DiskResponse>* streamer) {
                       return this->StreamedGetDiskBPS(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDiskBPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDiskBPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDiskBPS(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mon::DiskQ,::mon::DiskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetIOPS() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::AllDiskResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::AllDiskResponse>* streamer) {
                       return this->StreamedGetIOPS(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIOPS(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIOPS(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::AllDiskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDiskIOPS : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDiskIOPS() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mon::DiskQ, ::mon::DiskResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mon::DiskQ, ::mon::DiskResponse>* streamer) {
                       return this->StreamedGetDiskIOPS(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDiskIOPS() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDiskIOPS(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDiskIOPS(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mon::DiskQ,::mon::DiskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::AllDiskResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::AllDiskResponse>* streamer) {
                       return this->StreamedGetRequestSizeInBytesPerRead(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllDiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRequestSizeInBytesPerRead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::AllDiskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDiskRequestSizeInBytesPerRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDiskRequestSizeInBytesPerRead() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mon::DiskQ, ::mon::DiskResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mon::DiskQ, ::mon::DiskResponse>* streamer) {
                       return this->StreamedGetDiskRequestSizeInBytesPerRead(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDiskRequestSizeInBytesPerRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* /*context*/, const ::mon::DiskQ* /*request*/, ::mon::DiskResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDiskRequestSizeInBytesPerRead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mon::DiskQ,::mon::DiskResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetBPS<WithStreamedUnaryMethod_GetDiskBPS<WithStreamedUnaryMethod_GetIOPS<WithStreamedUnaryMethod_GetDiskIOPS<WithStreamedUnaryMethod_GetRequestSizeInBytesPerRead<WithStreamedUnaryMethod_GetDiskRequestSizeInBytesPerRead<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetBPS<WithStreamedUnaryMethod_GetDiskBPS<WithStreamedUnaryMethod_GetIOPS<WithStreamedUnaryMethod_GetDiskIOPS<WithStreamedUnaryMethod_GetRequestSizeInBytesPerRead<WithStreamedUnaryMethod_GetDiskRequestSizeInBytesPerRead<Service > > > > > > StreamedService;
};

// Network
class NetworkMonitoring final {
 public:
  static constexpr char const* service_full_name() {
    return "mon.NetworkMonitoring";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllIfaceResponses* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>> AsyncGetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>>(AsyncGetBytesPerSecondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>> PrepareAsyncGetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>>(PrepareAsyncGetBytesPerSecondRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::mon::IfaceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>> AsyncGetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>>(AsyncGetIfaceBytesPerSecondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>> PrepareAsyncGetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>>(PrepareAsyncGetIfaceBytesPerSecondRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllIfaceResponses* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>> AsyncGetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>>(AsyncGetPacketsPerSecondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>> PrepareAsyncGetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>>(PrepareAsyncGetPacketsPerSecondRaw(context, request, cq));
    }
    virtual ::grpc::Status GetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::mon::IfaceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>> AsyncGetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>>(AsyncGetIfacePacketsPerSecondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>> PrepareAsyncGetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>>(PrepareAsyncGetIfacePacketsPerSecondRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>* AsyncGetBytesPerSecondRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>* PrepareAsyncGetBytesPerSecondRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>* AsyncGetIfaceBytesPerSecondRaw(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>* PrepareAsyncGetIfaceBytesPerSecondRaw(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>* AsyncGetPacketsPerSecondRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::AllIfaceResponses>* PrepareAsyncGetPacketsPerSecondRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>* AsyncGetIfacePacketsPerSecondRaw(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::IfaceResponse>* PrepareAsyncGetIfacePacketsPerSecondRaw(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllIfaceResponses* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>> AsyncGetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>>(AsyncGetBytesPerSecondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>> PrepareAsyncGetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>>(PrepareAsyncGetBytesPerSecondRaw(context, request, cq));
    }
    ::grpc::Status GetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::mon::IfaceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>> AsyncGetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>>(AsyncGetIfaceBytesPerSecondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>> PrepareAsyncGetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>>(PrepareAsyncGetIfaceBytesPerSecondRaw(context, request, cq));
    }
    ::grpc::Status GetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::AllIfaceResponses* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>> AsyncGetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>>(AsyncGetPacketsPerSecondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>> PrepareAsyncGetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>>(PrepareAsyncGetPacketsPerSecondRaw(context, request, cq));
    }
    ::grpc::Status GetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::mon::IfaceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>> AsyncGetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>>(AsyncGetIfacePacketsPerSecondRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>> PrepareAsyncGetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>>(PrepareAsyncGetIfacePacketsPerSecondRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response, std::function<void(::grpc::Status)>) override;
      void GetBytesPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response, std::function<void(::grpc::Status)>) override;
      void GetIfaceBytesPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response, std::function<void(::grpc::Status)>) override;
      void GetPacketsPerSecond(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response, std::function<void(::grpc::Status)>) override;
      void GetIfacePacketsPerSecond(::grpc::ClientContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>* AsyncGetBytesPerSecondRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>* PrepareAsyncGetBytesPerSecondRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>* AsyncGetIfaceBytesPerSecondRaw(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>* PrepareAsyncGetIfaceBytesPerSecondRaw(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>* AsyncGetPacketsPerSecondRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::AllIfaceResponses>* PrepareAsyncGetPacketsPerSecondRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>* AsyncGetIfacePacketsPerSecondRaw(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::IfaceResponse>* PrepareAsyncGetIfacePacketsPerSecondRaw(::grpc::ClientContext* context, const ::mon::IfaceQ& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetBytesPerSecond_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIfaceBytesPerSecond_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPacketsPerSecond_;
    const ::grpc::internal::RpcMethod rpcmethod_GetIfacePacketsPerSecond_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetBytesPerSecond(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response);
    virtual ::grpc::Status GetIfaceBytesPerSecond(::grpc::ServerContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response);
    virtual ::grpc::Status GetPacketsPerSecond(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response);
    virtual ::grpc::Status GetIfacePacketsPerSecond(::grpc::ServerContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBytesPerSecond() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBytesPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBytesPerSecond(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::AllIfaceResponses>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIfaceBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetIfaceBytesPerSecond() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetIfaceBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfaceBytesPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIfaceBytesPerSecond(::grpc::ServerContext* context, ::mon::IfaceQ* request, ::grpc::ServerAsyncResponseWriter< ::mon::IfaceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPacketsPerSecond() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetPacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPacketsPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPacketsPerSecond(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::AllIfaceResponses>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetIfacePacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetIfacePacketsPerSecond() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetIfacePacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfacePacketsPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIfacePacketsPerSecond(::grpc::ServerContext* context, ::mon::IfaceQ* request, ::grpc::ServerAsyncResponseWriter< ::mon::IfaceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetBytesPerSecond<WithAsyncMethod_GetIfaceBytesPerSecond<WithAsyncMethod_GetPacketsPerSecond<WithAsyncMethod_GetIfacePacketsPerSecond<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBytesPerSecond() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllIfaceResponses>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response) { return this->GetBytesPerSecond(context, request, response); }));}
    void SetMessageAllocatorFor_GetBytesPerSecond(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::AllIfaceResponses>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllIfaceResponses>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBytesPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBytesPerSecond(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetIfaceBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetIfaceBytesPerSecond() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::mon::IfaceQ, ::mon::IfaceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response) { return this->GetIfaceBytesPerSecond(context, request, response); }));}
    void SetMessageAllocatorFor_GetIfaceBytesPerSecond(
        ::grpc::MessageAllocator< ::mon::IfaceQ, ::mon::IfaceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mon::IfaceQ, ::mon::IfaceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetIfaceBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfaceBytesPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIfaceBytesPerSecond(
      ::grpc::CallbackServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPacketsPerSecond() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllIfaceResponses>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::AllIfaceResponses* response) { return this->GetPacketsPerSecond(context, request, response); }));}
    void SetMessageAllocatorFor_GetPacketsPerSecond(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::AllIfaceResponses>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::AllIfaceResponses>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPacketsPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPacketsPerSecond(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetIfacePacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetIfacePacketsPerSecond() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::mon::IfaceQ, ::mon::IfaceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mon::IfaceQ* request, ::mon::IfaceResponse* response) { return this->GetIfacePacketsPerSecond(context, request, response); }));}
    void SetMessageAllocatorFor_GetIfacePacketsPerSecond(
        ::grpc::MessageAllocator< ::mon::IfaceQ, ::mon::IfaceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mon::IfaceQ, ::mon::IfaceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetIfacePacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfacePacketsPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIfacePacketsPerSecond(
      ::grpc::CallbackServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetBytesPerSecond<WithCallbackMethod_GetIfaceBytesPerSecond<WithCallbackMethod_GetPacketsPerSecond<WithCallbackMethod_GetIfacePacketsPerSecond<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBytesPerSecond() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBytesPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIfaceBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetIfaceBytesPerSecond() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetIfaceBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfaceBytesPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPacketsPerSecond() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetPacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPacketsPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetIfacePacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetIfacePacketsPerSecond() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetIfacePacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfacePacketsPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBytesPerSecond() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBytesPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBytesPerSecond(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIfaceBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetIfaceBytesPerSecond() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetIfaceBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfaceBytesPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIfaceBytesPerSecond(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPacketsPerSecond() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetPacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPacketsPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPacketsPerSecond(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetIfacePacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetIfacePacketsPerSecond() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetIfacePacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfacePacketsPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetIfacePacketsPerSecond(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBytesPerSecond() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBytesPerSecond(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBytesPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetBytesPerSecond(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetIfaceBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetIfaceBytesPerSecond() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetIfaceBytesPerSecond(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetIfaceBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfaceBytesPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIfaceBytesPerSecond(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPacketsPerSecond() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPacketsPerSecond(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPacketsPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPacketsPerSecond(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetIfacePacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetIfacePacketsPerSecond() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetIfacePacketsPerSecond(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetIfacePacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetIfacePacketsPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetIfacePacketsPerSecond(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBytesPerSecond() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::AllIfaceResponses>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::AllIfaceResponses>* streamer) {
                       return this->StreamedGetBytesPerSecond(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBytesPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBytesPerSecond(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::AllIfaceResponses>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIfaceBytesPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetIfaceBytesPerSecond() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mon::IfaceQ, ::mon::IfaceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mon::IfaceQ, ::mon::IfaceResponse>* streamer) {
                       return this->StreamedGetIfaceBytesPerSecond(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetIfaceBytesPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIfaceBytesPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIfaceBytesPerSecond(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mon::IfaceQ,::mon::IfaceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPacketsPerSecond() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::AllIfaceResponses>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::AllIfaceResponses>* streamer) {
                       return this->StreamedGetPacketsPerSecond(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPacketsPerSecond(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::AllIfaceResponses* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPacketsPerSecond(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::AllIfaceResponses>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetIfacePacketsPerSecond : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetIfacePacketsPerSecond() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mon::IfaceQ, ::mon::IfaceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mon::IfaceQ, ::mon::IfaceResponse>* streamer) {
                       return this->StreamedGetIfacePacketsPerSecond(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetIfacePacketsPerSecond() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetIfacePacketsPerSecond(::grpc::ServerContext* /*context*/, const ::mon::IfaceQ* /*request*/, ::mon::IfaceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetIfacePacketsPerSecond(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mon::IfaceQ,::mon::IfaceResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetBytesPerSecond<WithStreamedUnaryMethod_GetIfaceBytesPerSecond<WithStreamedUnaryMethod_GetPacketsPerSecond<WithStreamedUnaryMethod_GetIfacePacketsPerSecond<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetBytesPerSecond<WithStreamedUnaryMethod_GetIfaceBytesPerSecond<WithStreamedUnaryMethod_GetPacketsPerSecond<WithStreamedUnaryMethod_GetIfacePacketsPerSecond<Service > > > > StreamedService;
};

// Memory
class MemoryMonitoring final {
 public:
  static constexpr char const* service_full_name() {
    return "mon.MemoryMonitoring";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::FreeMemory* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::FreeMemory>> AsyncGetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::FreeMemory>>(AsyncGetFreeMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::FreeMemory>> PrepareAsyncGetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::FreeMemory>>(PrepareAsyncGetFreeMemoryRaw(context, request, cq));
    }
    virtual ::grpc::Status GetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::UsedMemory* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::UsedMemory>> AsyncGetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::UsedMemory>>(AsyncGetUsedMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::UsedMemory>> PrepareAsyncGetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::UsedMemory>>(PrepareAsyncGetUsedMemoryRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::CachedMemory* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::CachedMemory>> AsyncGetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::CachedMemory>>(AsyncGetCachedMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::CachedMemory>> PrepareAsyncGetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::CachedMemory>>(PrepareAsyncGetCachedMemoryRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::SwapMemory* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::SwapMemory>> AsyncGetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::SwapMemory>>(AsyncGetSwapMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::SwapMemory>> PrepareAsyncGetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::SwapMemory>>(PrepareAsyncGetSwapMemoryRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::TotalMemory* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::TotalMemory>> AsyncGetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::TotalMemory>>(AsyncGetTotalMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::TotalMemory>> PrepareAsyncGetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::TotalMemory>>(PrepareAsyncGetTotalMemoryRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::FreeMemory* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::FreeMemory* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::UsedMemory* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::UsedMemory* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::CachedMemory* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::CachedMemory* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::SwapMemory* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::SwapMemory* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::TotalMemory* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::TotalMemory* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::FreeMemory>* AsyncGetFreeMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::FreeMemory>* PrepareAsyncGetFreeMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::UsedMemory>* AsyncGetUsedMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::UsedMemory>* PrepareAsyncGetUsedMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::CachedMemory>* AsyncGetCachedMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::CachedMemory>* PrepareAsyncGetCachedMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::SwapMemory>* AsyncGetSwapMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::SwapMemory>* PrepareAsyncGetSwapMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::TotalMemory>* AsyncGetTotalMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::TotalMemory>* PrepareAsyncGetTotalMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::FreeMemory* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::FreeMemory>> AsyncGetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::FreeMemory>>(AsyncGetFreeMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::FreeMemory>> PrepareAsyncGetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::FreeMemory>>(PrepareAsyncGetFreeMemoryRaw(context, request, cq));
    }
    ::grpc::Status GetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::UsedMemory* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::UsedMemory>> AsyncGetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::UsedMemory>>(AsyncGetUsedMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::UsedMemory>> PrepareAsyncGetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::UsedMemory>>(PrepareAsyncGetUsedMemoryRaw(context, request, cq));
    }
    ::grpc::Status GetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::CachedMemory* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::CachedMemory>> AsyncGetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::CachedMemory>>(AsyncGetCachedMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::CachedMemory>> PrepareAsyncGetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::CachedMemory>>(PrepareAsyncGetCachedMemoryRaw(context, request, cq));
    }
    ::grpc::Status GetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::SwapMemory* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::SwapMemory>> AsyncGetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::SwapMemory>>(AsyncGetSwapMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::SwapMemory>> PrepareAsyncGetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::SwapMemory>>(PrepareAsyncGetSwapMemoryRaw(context, request, cq));
    }
    ::grpc::Status GetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::TotalMemory* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::TotalMemory>> AsyncGetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::TotalMemory>>(AsyncGetTotalMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::TotalMemory>> PrepareAsyncGetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::TotalMemory>>(PrepareAsyncGetTotalMemoryRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::FreeMemory* response, std::function<void(::grpc::Status)>) override;
      void GetFreeMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::FreeMemory* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::UsedMemory* response, std::function<void(::grpc::Status)>) override;
      void GetUsedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::UsedMemory* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::CachedMemory* response, std::function<void(::grpc::Status)>) override;
      void GetCachedMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::CachedMemory* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::SwapMemory* response, std::function<void(::grpc::Status)>) override;
      void GetSwapMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::SwapMemory* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::TotalMemory* response, std::function<void(::grpc::Status)>) override;
      void GetTotalMemory(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::TotalMemory* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mon::FreeMemory>* AsyncGetFreeMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::FreeMemory>* PrepareAsyncGetFreeMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::UsedMemory>* AsyncGetUsedMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::UsedMemory>* PrepareAsyncGetUsedMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::CachedMemory>* AsyncGetCachedMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::CachedMemory>* PrepareAsyncGetCachedMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::SwapMemory>* AsyncGetSwapMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::SwapMemory>* PrepareAsyncGetSwapMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::TotalMemory>* AsyncGetTotalMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::TotalMemory>* PrepareAsyncGetTotalMemoryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetFreeMemory_;
    const ::grpc::internal::RpcMethod rpcmethod_GetUsedMemory_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCachedMemory_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSwapMemory_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTotalMemory_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetFreeMemory(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::FreeMemory* response);
    virtual ::grpc::Status GetUsedMemory(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::UsedMemory* response);
    virtual ::grpc::Status GetCachedMemory(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::CachedMemory* response);
    virtual ::grpc::Status GetSwapMemory(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::SwapMemory* response);
    virtual ::grpc::Status GetTotalMemory(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::TotalMemory* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFreeMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFreeMemory() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetFreeMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFreeMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::FreeMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFreeMemory(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::FreeMemory>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetUsedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetUsedMemory() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetUsedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::UsedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUsedMemory(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::UsedMemory>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCachedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCachedMemory() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetCachedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCachedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CachedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCachedMemory(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::CachedMemory>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSwapMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSwapMemory() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetSwapMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSwapMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::SwapMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSwapMemory(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::SwapMemory>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTotalMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTotalMemory() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetTotalMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTotalMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::TotalMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTotalMemory(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::TotalMemory>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetFreeMemory<WithAsyncMethod_GetUsedMemory<WithAsyncMethod_GetCachedMemory<WithAsyncMethod_GetSwapMemory<WithAsyncMethod_GetTotalMemory<Service > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetFreeMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFreeMemory() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::FreeMemory>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::FreeMemory* response) { return this->GetFreeMemory(context, request, response); }));}
    void SetMessageAllocatorFor_GetFreeMemory(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::FreeMemory>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::FreeMemory>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFreeMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFreeMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::FreeMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFreeMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::FreeMemory* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetUsedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetUsedMemory() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::UsedMemory>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::UsedMemory* response) { return this->GetUsedMemory(context, request, response); }));}
    void SetMessageAllocatorFor_GetUsedMemory(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::UsedMemory>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::UsedMemory>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetUsedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::UsedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetUsedMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::UsedMemory* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCachedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCachedMemory() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::CachedMemory>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::CachedMemory* response) { return this->GetCachedMemory(context, request, response); }));}
    void SetMessageAllocatorFor_GetCachedMemory(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::CachedMemory>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::CachedMemory>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCachedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCachedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CachedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCachedMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CachedMemory* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSwapMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSwapMemory() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::SwapMemory>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::SwapMemory* response) { return this->GetSwapMemory(context, request, response); }));}
    void SetMessageAllocatorFor_GetSwapMemory(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::SwapMemory>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::SwapMemory>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSwapMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSwapMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::SwapMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSwapMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::SwapMemory* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTotalMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTotalMemory() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::TotalMemory>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::TotalMemory* response) { return this->GetTotalMemory(context, request, response); }));}
    void SetMessageAllocatorFor_GetTotalMemory(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::TotalMemory>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::TotalMemory>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTotalMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTotalMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::TotalMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTotalMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::TotalMemory* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetFreeMemory<WithCallbackMethod_GetUsedMemory<WithCallbackMethod_GetCachedMemory<WithCallbackMethod_GetSwapMemory<WithCallbackMethod_GetTotalMemory<Service > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetFreeMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFreeMemory() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetFreeMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFreeMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::FreeMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetUsedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetUsedMemory() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetUsedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::UsedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCachedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCachedMemory() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetCachedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCachedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CachedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSwapMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSwapMemory() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetSwapMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSwapMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::SwapMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTotalMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTotalMemory() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetTotalMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTotalMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::TotalMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFreeMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFreeMemory() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetFreeMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFreeMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::FreeMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFreeMemory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetUsedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetUsedMemory() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetUsedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::UsedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUsedMemory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCachedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCachedMemory() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetCachedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCachedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CachedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCachedMemory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSwapMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSwapMemory() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetSwapMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSwapMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::SwapMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSwapMemory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTotalMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTotalMemory() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetTotalMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTotalMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::TotalMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTotalMemory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFreeMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFreeMemory() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFreeMemory(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFreeMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFreeMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::FreeMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFreeMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetUsedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetUsedMemory() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetUsedMemory(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetUsedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::UsedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetUsedMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCachedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCachedMemory() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCachedMemory(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCachedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCachedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CachedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCachedMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSwapMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSwapMemory() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSwapMemory(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSwapMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSwapMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::SwapMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSwapMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTotalMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTotalMemory() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTotalMemory(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTotalMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTotalMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::TotalMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTotalMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFreeMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFreeMemory() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::FreeMemory>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::FreeMemory>* streamer) {
                       return this->StreamedGetFreeMemory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFreeMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFreeMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::FreeMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFreeMemory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::FreeMemory>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetUsedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetUsedMemory() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::UsedMemory>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::UsedMemory>* streamer) {
                       return this->StreamedGetUsedMemory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetUsedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetUsedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::UsedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetUsedMemory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::UsedMemory>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCachedMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCachedMemory() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::CachedMemory>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::CachedMemory>* streamer) {
                       return this->StreamedGetCachedMemory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCachedMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCachedMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CachedMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCachedMemory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::CachedMemory>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSwapMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSwapMemory() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::SwapMemory>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::SwapMemory>* streamer) {
                       return this->StreamedGetSwapMemory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSwapMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSwapMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::SwapMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSwapMemory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::SwapMemory>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTotalMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTotalMemory() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::TotalMemory>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::TotalMemory>* streamer) {
                       return this->StreamedGetTotalMemory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTotalMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTotalMemory(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::TotalMemory* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTotalMemory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::TotalMemory>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetFreeMemory<WithStreamedUnaryMethod_GetUsedMemory<WithStreamedUnaryMethod_GetCachedMemory<WithStreamedUnaryMethod_GetSwapMemory<WithStreamedUnaryMethod_GetTotalMemory<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetFreeMemory<WithStreamedUnaryMethod_GetUsedMemory<WithStreamedUnaryMethod_GetCachedMemory<WithStreamedUnaryMethod_GetSwapMemory<WithStreamedUnaryMethod_GetTotalMemory<Service > > > > > StreamedService;
};

// CPU
class CpuMonitoring final {
 public:
  static constexpr char const* service_full_name() {
    return "mon.CpuMonitoring";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::CpuResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::CpuResponse>> AsyncGetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::CpuResponse>>(AsyncGetUsagePercentageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::CpuResponse>> PrepareAsyncGetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mon::CpuResponse>>(PrepareAsyncGetUsagePercentageRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::CpuResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::CpuResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::CpuResponse>* AsyncGetUsagePercentageRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mon::CpuResponse>* PrepareAsyncGetUsagePercentageRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::mon::CpuResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::CpuResponse>> AsyncGetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::CpuResponse>>(AsyncGetUsagePercentageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::CpuResponse>> PrepareAsyncGetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mon::CpuResponse>>(PrepareAsyncGetUsagePercentageRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::CpuResponse* response, std::function<void(::grpc::Status)>) override;
      void GetUsagePercentage(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::mon::CpuResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mon::CpuResponse>* AsyncGetUsagePercentageRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mon::CpuResponse>* PrepareAsyncGetUsagePercentageRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetUsagePercentage_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetUsagePercentage(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::mon::CpuResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetUsagePercentage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetUsagePercentage() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetUsagePercentage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsagePercentage(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CpuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUsagePercentage(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::mon::CpuResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetUsagePercentage<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetUsagePercentage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetUsagePercentage() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::CpuResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::mon::CpuResponse* response) { return this->GetUsagePercentage(context, request, response); }));}
    void SetMessageAllocatorFor_GetUsagePercentage(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::mon::CpuResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::mon::CpuResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetUsagePercentage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsagePercentage(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CpuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetUsagePercentage(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CpuResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetUsagePercentage<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetUsagePercentage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetUsagePercentage() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetUsagePercentage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsagePercentage(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CpuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetUsagePercentage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetUsagePercentage() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetUsagePercentage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsagePercentage(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CpuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUsagePercentage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetUsagePercentage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetUsagePercentage() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetUsagePercentage(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetUsagePercentage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsagePercentage(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CpuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetUsagePercentage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetUsagePercentage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetUsagePercentage() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::mon::CpuResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::mon::CpuResponse>* streamer) {
                       return this->StreamedGetUsagePercentage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetUsagePercentage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetUsagePercentage(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::mon::CpuResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetUsagePercentage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::mon::CpuResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetUsagePercentage<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetUsagePercentage<Service > StreamedService;
};

}  // namespace mon


#endif  // GRPC_monitoring_2eproto__INCLUDED
